{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport dirBuilder from './dir.js';\nimport fileBuilder from './file/index.js';\nimport errCode from 'err-code';\nimport rabin from '../chunker/rabin.js';\nimport fixedSize from '../chunker/fixed-size.js';\nimport validateChunks from './validate-chunks.js';\n\nfunction isIterable(thing) {\n  return Symbol.iterator in thing;\n}\n\nfunction isAsyncIterable(thing) {\n  return Symbol.asyncIterator in thing;\n}\n\nfunction contentAsAsyncIterable(content) {\n  try {\n    if (content instanceof Uint8Array) {\n      return async function* () {\n        yield content;\n      }();\n    } else if (isIterable(content)) {\n      return async function* () {\n        yield* content;\n      }();\n    } else if (isAsyncIterable(content)) {\n      return content;\n    }\n  } catch {\n    throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n  }\n\n  throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n}\n\nasync function* dagBuilder(source, blockstore, options) {\n  for await (const entry of source) {\n    if (entry.path) {\n      if (entry.path.substring(0, 2) === './') {\n        options.wrapWithDirectory = true;\n      }\n\n      entry.path = entry.path.split('/').filter(path => path && path !== '.').join('/');\n    }\n\n    if (entry.content) {\n      let chunker;\n\n      if (typeof options.chunker === 'function') {\n        chunker = options.chunker;\n      } else if (options.chunker === 'rabin') {\n        chunker = rabin;\n      } else {\n        chunker = fixedSize;\n      }\n\n      let chunkValidator;\n\n      if (typeof options.chunkValidator === 'function') {\n        chunkValidator = options.chunkValidator;\n      } else {\n        chunkValidator = validateChunks;\n      }\n\n      const file = {\n        path: entry.path,\n        mtime: entry.mtime,\n        mode: entry.mode,\n        content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)\n      };\n      yield () => fileBuilder(file, blockstore, options);\n    } else if (entry.path) {\n      const dir = {\n        path: entry.path,\n        mtime: entry.mtime,\n        mode: entry.mode\n      };\n      yield () => dirBuilder(dir, blockstore, options);\n    } else {\n      throw new Error('Import candidate must have content or path or both');\n    }\n  }\n}\n\nexport default dagBuilder;","map":{"version":3,"names":["dirBuilder","fileBuilder","errCode","rabin","fixedSize","validateChunks","isIterable","thing","Symbol","iterator","isAsyncIterable","asyncIterator","contentAsAsyncIterable","content","Uint8Array","Error","dagBuilder","source","blockstore","options","entry","path","substring","wrapWithDirectory","split","filter","join","chunker","chunkValidator","file","mtime","mode","dir"],"sources":["/var/www/ch-8-car-renting/frontend/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/index.js"],"sourcesContent":["import dirBuilder from './dir.js';\nimport fileBuilder from './file/index.js';\nimport errCode from 'err-code';\nimport rabin from '../chunker/rabin.js';\nimport fixedSize from '../chunker/fixed-size.js';\nimport validateChunks from './validate-chunks.js';\nfunction isIterable(thing) {\n  return Symbol.iterator in thing;\n}\nfunction isAsyncIterable(thing) {\n  return Symbol.asyncIterator in thing;\n}\nfunction contentAsAsyncIterable(content) {\n  try {\n    if (content instanceof Uint8Array) {\n      return async function* () {\n        yield content;\n      }();\n    } else if (isIterable(content)) {\n      return async function* () {\n        yield* content;\n      }();\n    } else if (isAsyncIterable(content)) {\n      return content;\n    }\n  } catch {\n    throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n  }\n  throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n}\nasync function* dagBuilder(source, blockstore, options) {\n  for await (const entry of source) {\n    if (entry.path) {\n      if (entry.path.substring(0, 2) === './') {\n        options.wrapWithDirectory = true;\n      }\n      entry.path = entry.path.split('/').filter(path => path && path !== '.').join('/');\n    }\n    if (entry.content) {\n      let chunker;\n      if (typeof options.chunker === 'function') {\n        chunker = options.chunker;\n      } else if (options.chunker === 'rabin') {\n        chunker = rabin;\n      } else {\n        chunker = fixedSize;\n      }\n      let chunkValidator;\n      if (typeof options.chunkValidator === 'function') {\n        chunkValidator = options.chunkValidator;\n      } else {\n        chunkValidator = validateChunks;\n      }\n      const file = {\n        path: entry.path,\n        mtime: entry.mtime,\n        mode: entry.mode,\n        content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)\n      };\n      yield () => fileBuilder(file, blockstore, options);\n    } else if (entry.path) {\n      const dir = {\n        path: entry.path,\n        mtime: entry.mtime,\n        mode: entry.mode\n      };\n      yield () => dirBuilder(dir, blockstore, options);\n    } else {\n      throw new Error('Import candidate must have content or path or both');\n    }\n  }\n}\nexport default dagBuilder;"],"mappings":";;;AAAA,OAAOA,UAAP,MAAuB,UAAvB;AACA,OAAOC,WAAP,MAAwB,iBAAxB;AACA,OAAOC,OAAP,MAAoB,UAApB;AACA,OAAOC,KAAP,MAAkB,qBAAlB;AACA,OAAOC,SAAP,MAAsB,0BAAtB;AACA,OAAOC,cAAP,MAA2B,sBAA3B;;AACA,SAASC,UAAT,CAAoBC,KAApB,EAA2B;EACzB,OAAOC,MAAM,CAACC,QAAP,IAAmBF,KAA1B;AACD;;AACD,SAASG,eAAT,CAAyBH,KAAzB,EAAgC;EAC9B,OAAOC,MAAM,CAACG,aAAP,IAAwBJ,KAA/B;AACD;;AACD,SAASK,sBAAT,CAAgCC,OAAhC,EAAyC;EACvC,IAAI;IACF,IAAIA,OAAO,YAAYC,UAAvB,EAAmC;MACjC,OAAO,mBAAmB;QACxB,MAAMD,OAAN;MACD,CAFM,EAAP;IAGD,CAJD,MAIO,IAAIP,UAAU,CAACO,OAAD,CAAd,EAAyB;MAC9B,OAAO,mBAAmB;QACxB,OAAOA,OAAP;MACD,CAFM,EAAP;IAGD,CAJM,MAIA,IAAIH,eAAe,CAACG,OAAD,CAAnB,EAA8B;MACnC,OAAOA,OAAP;IACD;EACF,CAZD,CAYE,MAAM;IACN,MAAMX,OAAO,CAAC,IAAIa,KAAJ,CAAU,qBAAV,CAAD,EAAmC,qBAAnC,CAAb;EACD;;EACD,MAAMb,OAAO,CAAC,IAAIa,KAAJ,CAAU,qBAAV,CAAD,EAAmC,qBAAnC,CAAb;AACD;;AACD,gBAAgBC,UAAhB,CAA2BC,MAA3B,EAAmCC,UAAnC,EAA+CC,OAA/C,EAAwD;EACtD,WAAW,MAAMC,KAAjB,IAA0BH,MAA1B,EAAkC;IAChC,IAAIG,KAAK,CAACC,IAAV,EAAgB;MACd,IAAID,KAAK,CAACC,IAAN,CAAWC,SAAX,CAAqB,CAArB,EAAwB,CAAxB,MAA+B,IAAnC,EAAyC;QACvCH,OAAO,CAACI,iBAAR,GAA4B,IAA5B;MACD;;MACDH,KAAK,CAACC,IAAN,GAAaD,KAAK,CAACC,IAAN,CAAWG,KAAX,CAAiB,GAAjB,EAAsBC,MAAtB,CAA6BJ,IAAI,IAAIA,IAAI,IAAIA,IAAI,KAAK,GAAtD,EAA2DK,IAA3D,CAAgE,GAAhE,CAAb;IACD;;IACD,IAAIN,KAAK,CAACP,OAAV,EAAmB;MACjB,IAAIc,OAAJ;;MACA,IAAI,OAAOR,OAAO,CAACQ,OAAf,KAA2B,UAA/B,EAA2C;QACzCA,OAAO,GAAGR,OAAO,CAACQ,OAAlB;MACD,CAFD,MAEO,IAAIR,OAAO,CAACQ,OAAR,KAAoB,OAAxB,EAAiC;QACtCA,OAAO,GAAGxB,KAAV;MACD,CAFM,MAEA;QACLwB,OAAO,GAAGvB,SAAV;MACD;;MACD,IAAIwB,cAAJ;;MACA,IAAI,OAAOT,OAAO,CAACS,cAAf,KAAkC,UAAtC,EAAkD;QAChDA,cAAc,GAAGT,OAAO,CAACS,cAAzB;MACD,CAFD,MAEO;QACLA,cAAc,GAAGvB,cAAjB;MACD;;MACD,MAAMwB,IAAI,GAAG;QACXR,IAAI,EAAED,KAAK,CAACC,IADD;QAEXS,KAAK,EAAEV,KAAK,CAACU,KAFF;QAGXC,IAAI,EAAEX,KAAK,CAACW,IAHD;QAIXlB,OAAO,EAAEc,OAAO,CAACC,cAAc,CAAChB,sBAAsB,CAACQ,KAAK,CAACP,OAAP,CAAvB,EAAwCM,OAAxC,CAAf,EAAiEA,OAAjE;MAJL,CAAb;MAMA,MAAM,MAAMlB,WAAW,CAAC4B,IAAD,EAAOX,UAAP,EAAmBC,OAAnB,CAAvB;IACD,CAtBD,MAsBO,IAAIC,KAAK,CAACC,IAAV,EAAgB;MACrB,MAAMW,GAAG,GAAG;QACVX,IAAI,EAAED,KAAK,CAACC,IADF;QAEVS,KAAK,EAAEV,KAAK,CAACU,KAFH;QAGVC,IAAI,EAAEX,KAAK,CAACW;MAHF,CAAZ;MAKA,MAAM,MAAM/B,UAAU,CAACgC,GAAD,EAAMd,UAAN,EAAkBC,OAAlB,CAAtB;IACD,CAPM,MAOA;MACL,MAAM,IAAIJ,KAAJ,CAAU,oDAAV,CAAN;IACD;EACF;AACF;;AACD,eAAeC,UAAf"},"metadata":{},"sourceType":"module"}