import { __awaiter } from "tslib";
import isMobile from "is-mobile";
import { waitFor, } from "@near-wallet-selector/core";
const INJECTED_WALLET_LOADING_MS = 300;
export function setupSender({ iconUrl, } = {}) {
    return function Sender({ options, network, emitter, logger, updateState }) {
        let wallet;
        const getAccounts = () => {
            const accountId = wallet.getAccountId();
            if (!accountId) {
                return [];
            }
            return [{ accountId }];
        };
        const isInstalled = () => __awaiter(this, void 0, void 0, function* () {
            try {
                return yield waitFor(() => { var _a; return !!((_a = window.near) === null || _a === void 0 ? void 0 : _a.isSender); }, {});
            }
            catch (e) {
                logger.log("Sender:isInstalled:error", e);
                return false;
            }
        });
        const isValidActions = (actions) => {
            return actions.every((x) => x.type === "FunctionCall");
        };
        const transformActions = (actions) => {
            const validActions = isValidActions(actions);
            if (!validActions) {
                throw new Error("Only 'FunctionCall' actions types are supported by Sender");
            }
            return actions.map((x) => x.params);
        };
        const transformTransactions = (transactions) => {
            return transactions.map((transaction) => {
                return {
                    receiverId: transaction.receiverId,
                    actions: transformActions(transaction.actions),
                };
            });
        };
        return {
            id: "sender",
            type: "injected",
            name: "Sender",
            description: null,
            iconUrl: iconUrl || "./assets/sender-icon.png",
            downloadUrl: "https://chrome.google.com/webstore/detail/sender-wallet/epapihdplajcdnnkdeiahlgigofloibg",
            isAvailable() {
                if (!isInstalled()) {
                    return false;
                }
                if (isMobile()) {
                    return false;
                }
                return true;
            },
            init() {
                return __awaiter(this, void 0, void 0, function* () {
                    if (!(yield isInstalled())) {
                        throw new Error("Wallet not installed");
                    }
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    wallet = window.near;
                    try {
                        // Add extra wait to ensure Sender signin status be read from browser extension background env
                        yield waitFor(() => wallet === null || wallet === void 0 ? void 0 : wallet.isSignedIn(), {
                            timeout: INJECTED_WALLET_LOADING_MS,
                        });
                    }
                    catch (e) {
                        logger.log("Sender:init: haven't signed in yet", e);
                    }
                    wallet.on("accountChanged", (newAccountId) => __awaiter(this, void 0, void 0, function* () {
                        logger.log("Sender:onAccountChange", newAccountId);
                        try {
                            yield this.signOut();
                            yield this.signIn();
                        }
                        catch (e) {
                            logger.log(`Failed to change account ${e.message}`);
                        }
                    }));
                    wallet.on("rpcChanged", (response) => {
                        if (network.networkId !== response.rpc.networkId) {
                            updateState((prevState) => (Object.assign(Object.assign({}, prevState), { showModal: true, showWalletOptions: false, showSwitchNetwork: true })));
                        }
                    });
                });
            },
            signIn() {
                return __awaiter(this, void 0, void 0, function* () {
                    if (!(yield isInstalled())) {
                        return updateState((prevState) => (Object.assign(Object.assign({}, prevState), { showWalletOptions: false, showWalletNotInstalled: this.id })));
                    }
                    if (!wallet) {
                        yield this.init();
                    }
                    const { accessKey, error } = yield wallet.requestSignIn({
                        contractId: options.contractId,
                        methodNames: options.methodNames,
                    });
                    if (!accessKey || error) {
                        throw new Error((typeof error === "string" ? error : error.type) ||
                            "Failed to sign in");
                    }
                    updateState((prevState) => (Object.assign(Object.assign({}, prevState), { showModal: false, selectedWalletId: this.id })));
                    const accounts = getAccounts();
                    emitter.emit("signIn", { accounts });
                    emitter.emit("accountsChanged", { accounts });
                });
            },
            isSignedIn() {
                return __awaiter(this, void 0, void 0, function* () {
                    return wallet.isSignedIn();
                });
            },
            signOut() {
                return __awaiter(this, void 0, void 0, function* () {
                    const res = yield wallet.signOut();
                    if (typeof res !== "boolean" && res.error) {
                        throw new Error((typeof res.error === "string" ? res.error : res.error.type) ||
                            "Failed to connect");
                    }
                    updateState((prevState) => (Object.assign(Object.assign({}, prevState), { selectedWalletId: null })));
                    const accounts = getAccounts();
                    emitter.emit("accountsChanged", { accounts });
                    emitter.emit("signOut", { accounts });
                });
            },
            getAccounts() {
                return __awaiter(this, void 0, void 0, function* () {
                    return getAccounts();
                });
            },
            signAndSendTransaction({ signerId, receiverId, actions }) {
                return __awaiter(this, void 0, void 0, function* () {
                    logger.log("Sender:signAndSendTransaction", {
                        signerId,
                        receiverId,
                        actions,
                    });
                    return wallet
                        .signAndSendTransaction({
                        receiverId,
                        actions: transformActions(actions),
                    })
                        .then((res) => {
                        var _a;
                        if (res.error) {
                            throw new Error(res.error);
                        }
                        // Shouldn't happen but avoids inconsistent responses.
                        if (!((_a = res.response) === null || _a === void 0 ? void 0 : _a.length)) {
                            throw new Error("Invalid response");
                        }
                        return res.response[0];
                    });
                });
            },
            signAndSendTransactions({ transactions }) {
                return __awaiter(this, void 0, void 0, function* () {
                    logger.log("Sender:signAndSendTransactions", { transactions });
                    return wallet
                        .requestSignTransactions({
                        transactions: transformTransactions(transactions),
                    })
                        .then((res) => {
                        var _a;
                        if (res.error) {
                            throw new Error(res.error);
                        }
                        // Shouldn't happen but avoids inconsistent responses.
                        if (!((_a = res.response) === null || _a === void 0 ? void 0 : _a.length)) {
                            throw new Error("Invalid response");
                        }
                        return res.response;
                    });
                });
            },
        };
    };
}
//# sourceMappingURL=sender.js.map