import { __awaiter } from "tslib";
import { WalletConnection, connect, keyStores, utils } from "near-api-js";
import * as nearApi from "near-api-js";
import { transformActions, } from "@near-wallet-selector/core";
export function setupNearWallet({ walletUrl, iconUrl, } = {}) {
    return function NearWallet({ options, network, emitter, logger, storage, updateState, }) {
        let keyStore;
        let wallet;
        const getAccounts = () => {
            const accountId = wallet.getAccountId();
            if (!accountId) {
                return [];
            }
            return [{ accountId }];
        };
        const getWalletUrl = () => {
            if (walletUrl) {
                return walletUrl;
            }
            switch (network.networkId) {
                case "mainnet":
                    return "https://wallet.near.org";
                case "testnet":
                    return "https://wallet.testnet.near.org";
                case "betanet":
                    return "https://wallet.betanet.near.org";
                default:
                    throw new Error("Invalid wallet URL");
            }
        };
        const transformTransactions = (transactions) => __awaiter(this, void 0, void 0, function* () {
            const account = wallet.account();
            const { networkId, signer, provider } = account.connection;
            const localKey = yield signer.getPublicKey(account.accountId, networkId);
            return Promise.all(transactions.map((transaction, index) => __awaiter(this, void 0, void 0, function* () {
                const actions = transformActions(transaction.actions);
                const accessKey = yield account.accessKeyForTransaction(transaction.receiverId, actions, localKey);
                if (!accessKey) {
                    throw new Error(`Failed to find matching key for transaction sent to ${transaction.receiverId}`);
                }
                const block = yield provider.block({ finality: "final" });
                return nearApi.transactions.createTransaction(account.accountId, utils.PublicKey.from(accessKey.public_key), transaction.receiverId, accessKey.access_key.nonce + index + 1, actions, utils.serialize.base_decode(block.header.hash));
            })));
        });
        return {
            id: "near-wallet",
            type: "browser",
            name: "NEAR Wallet",
            description: null,
            iconUrl: iconUrl || "./assets/near-wallet-icon.png",
            isAvailable() {
                return true;
            },
            init() {
                return __awaiter(this, void 0, void 0, function* () {
                    const localStorageKeyStore = new keyStores.BrowserLocalStorageKeyStore();
                    const near = yield connect(Object.assign(Object.assign({ keyStore: localStorageKeyStore, walletUrl: getWalletUrl() }, network), { headers: {} }));
                    wallet = new WalletConnection(near, "near_app");
                    keyStore = localStorageKeyStore;
                    // Cleanup up any pending keys (cancelled logins).
                    if (!wallet.isSignedIn()) {
                        yield localStorageKeyStore.clear();
                    }
                });
            },
            // We don't emit "signIn" or update state as we can't guarantee the user will
            // actually sign in. Best we can do is temporarily set it as selected and
            // validate on initialise.
            signIn() {
                return __awaiter(this, void 0, void 0, function* () {
                    if (!wallet) {
                        yield this.init();
                    }
                    yield wallet.requestSignIn({
                        contractId: options.contractId,
                        methodNames: options.methodNames,
                    });
                    // TODO: Find better way to do this without exposing 'LOCAL_STORAGE_SELECTED_WALLET_ID' in core.
                    storage.setItem("selectedWalletId", this.id);
                });
            },
            signOut() {
                return __awaiter(this, void 0, void 0, function* () {
                    if (!wallet) {
                        return;
                    }
                    wallet.signOut();
                    yield keyStore.clear();
                    updateState((prevState) => (Object.assign(Object.assign({}, prevState), { selectedWalletId: null })));
                    const accounts = getAccounts();
                    emitter.emit("accountsChanged", { accounts });
                    emitter.emit("signOut", { accounts });
                });
            },
            isSignedIn() {
                return __awaiter(this, void 0, void 0, function* () {
                    if (!wallet) {
                        return false;
                    }
                    return wallet.isSignedIn();
                });
            },
            getAccounts() {
                return __awaiter(this, void 0, void 0, function* () {
                    return getAccounts();
                });
            },
            signAndSendTransaction({ signerId, receiverId, actions }) {
                return __awaiter(this, void 0, void 0, function* () {
                    logger.log("NearWallet:signAndSendTransaction", {
                        signerId,
                        receiverId,
                        actions,
                    });
                    const account = wallet.account();
                    return account["signAndSendTransaction"]({
                        receiverId,
                        actions: transformActions(actions),
                    }).then(() => {
                        // Suppress response since transactions with deposits won't actually
                        // return FinalExecutionOutcome.
                    });
                });
            },
            signAndSendTransactions({ transactions }) {
                return __awaiter(this, void 0, void 0, function* () {
                    logger.log("NearWallet:signAndSendTransactions", { transactions });
                    return wallet.requestSignTransactions({
                        transactions: yield transformTransactions(transactions),
                    });
                });
            },
        };
    };
}
//# sourceMappingURL=near-wallet.js.map