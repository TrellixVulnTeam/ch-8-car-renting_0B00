{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport { asyncIterableReader, bytesReader, createDecoder } from './decoder.js';\nexport class CarIndexer {\n  constructor(version, roots, iterator) {\n    this._version = version;\n    this._roots = roots;\n    this._iterator = iterator;\n  }\n\n  get version() {\n    return this._version;\n  }\n\n  async getRoots() {\n    return this._roots;\n  }\n\n  [Symbol.asyncIterator]() {\n    return this._iterator;\n  }\n\n  static async fromBytes(bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array');\n    }\n\n    return decodeIndexerComplete(bytesReader(bytes));\n  }\n\n  static async fromIterable(asyncIterable) {\n    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n      throw new TypeError('fromIterable() requires an async iterable');\n    }\n\n    return decodeIndexerComplete(asyncIterableReader(asyncIterable));\n  }\n\n}\n\nasync function decodeIndexerComplete(reader) {\n  const decoder = createDecoder(reader);\n  const {\n    version,\n    roots\n  } = await decoder.header();\n  return new CarIndexer(version, roots, decoder.blocksIndex());\n}","map":{"version":3,"names":["asyncIterableReader","bytesReader","createDecoder","CarIndexer","constructor","version","roots","iterator","_version","_roots","_iterator","getRoots","Symbol","asyncIterator","fromBytes","bytes","Uint8Array","TypeError","decodeIndexerComplete","fromIterable","asyncIterable","reader","decoder","header","blocksIndex"],"sources":["/var/www/ch-8-car-renting/frontend/node_modules/@ipld/car/esm/lib/indexer.js"],"sourcesContent":["import {\n  asyncIterableReader,\n  bytesReader,\n  createDecoder\n} from './decoder.js';\nexport class CarIndexer {\n  constructor(version, roots, iterator) {\n    this._version = version;\n    this._roots = roots;\n    this._iterator = iterator;\n  }\n  get version() {\n    return this._version;\n  }\n  async getRoots() {\n    return this._roots;\n  }\n  [Symbol.asyncIterator]() {\n    return this._iterator;\n  }\n  static async fromBytes(bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array');\n    }\n    return decodeIndexerComplete(bytesReader(bytes));\n  }\n  static async fromIterable(asyncIterable) {\n    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n      throw new TypeError('fromIterable() requires an async iterable');\n    }\n    return decodeIndexerComplete(asyncIterableReader(asyncIterable));\n  }\n}\nasync function decodeIndexerComplete(reader) {\n  const decoder = createDecoder(reader);\n  const {version, roots} = await decoder.header();\n  return new CarIndexer(version, roots, decoder.blocksIndex());\n}"],"mappings":";;;AAAA,SACEA,mBADF,EAEEC,WAFF,EAGEC,aAHF,QAIO,cAJP;AAKA,OAAO,MAAMC,UAAN,CAAiB;EACtBC,WAAW,CAACC,OAAD,EAAUC,KAAV,EAAiBC,QAAjB,EAA2B;IACpC,KAAKC,QAAL,GAAgBH,OAAhB;IACA,KAAKI,MAAL,GAAcH,KAAd;IACA,KAAKI,SAAL,GAAiBH,QAAjB;EACD;;EACU,IAAPF,OAAO,GAAG;IACZ,OAAO,KAAKG,QAAZ;EACD;;EACa,MAARG,QAAQ,GAAG;IACf,OAAO,KAAKF,MAAZ;EACD;;EACoB,CAApBG,MAAM,CAACC,aAAa,IAAI;IACvB,OAAO,KAAKH,SAAZ;EACD;;EACqB,aAATI,SAAS,CAACC,KAAD,EAAQ;IAC5B,IAAI,EAAEA,KAAK,YAAYC,UAAnB,CAAJ,EAAoC;MAClC,MAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;IACD;;IACD,OAAOC,qBAAqB,CAACjB,WAAW,CAACc,KAAD,CAAZ,CAA5B;EACD;;EACwB,aAAZI,YAAY,CAACC,aAAD,EAAgB;IACvC,IAAI,CAACA,aAAD,IAAkB,EAAE,OAAOA,aAAa,CAACR,MAAM,CAACC,aAAR,CAApB,KAA+C,UAAjD,CAAtB,EAAoF;MAClF,MAAM,IAAII,SAAJ,CAAc,2CAAd,CAAN;IACD;;IACD,OAAOC,qBAAqB,CAAClB,mBAAmB,CAACoB,aAAD,CAApB,CAA5B;EACD;;AA1BqB;;AA4BxB,eAAeF,qBAAf,CAAqCG,MAArC,EAA6C;EAC3C,MAAMC,OAAO,GAAGpB,aAAa,CAACmB,MAAD,CAA7B;EACA,MAAM;IAAChB,OAAD;IAAUC;EAAV,IAAmB,MAAMgB,OAAO,CAACC,MAAR,EAA/B;EACA,OAAO,IAAIpB,UAAJ,CAAeE,OAAf,EAAwBC,KAAxB,EAA+BgB,OAAO,CAACE,WAAR,EAA/B,CAAP;AACD"},"metadata":{},"sourceType":"module"}