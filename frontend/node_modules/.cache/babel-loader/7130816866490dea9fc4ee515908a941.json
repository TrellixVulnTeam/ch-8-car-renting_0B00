{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport varint from 'varint';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { decode as decodeDagCbor } from '@ipld/dag-cbor';\nconst CIDV0_BYTES = {\n  SHA2_256: 18,\n  LENGTH: 32,\n  DAG_PB: 112\n};\n\nasync function readVarint(reader) {\n  const bytes = await reader.upTo(8);\n  const i = varint.decode(bytes);\n  reader.seek(varint.decode.bytes);\n  return i;\n}\n\nexport async function readHeader(reader) {\n  const length = await readVarint(reader);\n\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)');\n  }\n\n  const header = await reader.exactly(length);\n  reader.seek(length);\n  const block = decodeDagCbor(header);\n\n  if (block == null || Array.isArray(block) || typeof block !== 'object') {\n    throw new Error('Invalid CAR header format');\n  }\n\n  if (block.version !== 1) {\n    if (typeof block.version === 'string') {\n      throw new Error(`Invalid CAR version: \"${block.version}\"`);\n    }\n\n    throw new Error(`Invalid CAR version: ${block.version}`);\n  }\n\n  if (!Array.isArray(block.roots)) {\n    throw new Error('Invalid CAR header format');\n  }\n\n  if (Object.keys(block).filter(p => p !== 'roots' && p !== 'version').length) {\n    throw new Error('Invalid CAR header format');\n  }\n\n  return block;\n}\n\nasync function readMultihash(reader) {\n  const bytes = await reader.upTo(8);\n  varint.decode(bytes);\n  const codeLength = varint.decode.bytes;\n  const length = varint.decode(bytes.subarray(varint.decode.bytes));\n  const lengthLength = varint.decode.bytes;\n  const mhLength = codeLength + lengthLength + length;\n  const multihash = await reader.exactly(mhLength);\n  reader.seek(mhLength);\n  return multihash;\n}\n\nasync function readCid(reader) {\n  const first = await reader.exactly(2);\n\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    const bytes = await reader.exactly(34);\n    reader.seek(34);\n    const multihash = Digest.decode(bytes);\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash);\n  }\n\n  const version = await readVarint(reader);\n\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${version})`);\n  }\n\n  const codec = await readVarint(reader);\n  const bytes = await readMultihash(reader);\n  const multihash = Digest.decode(bytes);\n  return CID.create(version, codec, multihash);\n}\n\nexport async function readBlockHead(reader) {\n  const start = reader.pos;\n  let length = await readVarint(reader);\n\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)');\n  }\n\n  length += reader.pos - start;\n  const cid = await readCid(reader);\n  const blockLength = length - (reader.pos - start);\n  return {\n    cid,\n    length,\n    blockLength\n  };\n}\n\nasync function readBlock(reader) {\n  const {\n    cid,\n    blockLength\n  } = await readBlockHead(reader);\n  const bytes = await reader.exactly(blockLength);\n  reader.seek(blockLength);\n  return {\n    bytes,\n    cid\n  };\n}\n\nasync function readBlockIndex(reader) {\n  const offset = reader.pos;\n  const {\n    cid,\n    length,\n    blockLength\n  } = await readBlockHead(reader);\n  const index = {\n    cid,\n    length,\n    blockLength,\n    offset,\n    blockOffset: reader.pos\n  };\n  reader.seek(index.blockLength);\n  return index;\n}\n\nexport function createDecoder(reader) {\n  const headerPromise = readHeader(reader);\n  return {\n    header: () => headerPromise,\n\n    async *blocks() {\n      await headerPromise;\n\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader);\n      }\n    },\n\n    async *blocksIndex() {\n      await headerPromise;\n\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader);\n      }\n    }\n\n  };\n}\nexport function bytesReader(bytes) {\n  let pos = 0;\n  return {\n    async upTo(length) {\n      return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));\n    },\n\n    async exactly(length) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data');\n      }\n\n      return bytes.subarray(pos, pos + length);\n    },\n\n    seek(length) {\n      pos += length;\n    },\n\n    get pos() {\n      return pos;\n    }\n\n  };\n}\nexport function chunkReader(readChunk) {\n  let pos = 0;\n  let have = 0;\n  let offset = 0;\n  let currentChunk = new Uint8Array(0);\n\n  const read = async length => {\n    have = currentChunk.length - offset;\n    const bufa = [currentChunk.subarray(offset)];\n\n    while (have < length) {\n      const chunk = await readChunk();\n\n      if (chunk == null) {\n        break;\n      }\n\n      if (have < 0) {\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have));\n        }\n      } else {\n        bufa.push(chunk);\n      }\n\n      have += chunk.length;\n    }\n\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));\n    let off = 0;\n\n    for (const b of bufa) {\n      currentChunk.set(b, off);\n      off += b.length;\n    }\n\n    offset = 0;\n  };\n\n  return {\n    async upTo(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length));\n    },\n\n    async exactly(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data');\n      }\n\n      return currentChunk.subarray(offset, offset + length);\n    },\n\n    seek(length) {\n      pos += length;\n      offset += length;\n    },\n\n    get pos() {\n      return pos;\n    }\n\n  };\n}\nexport function asyncIterableReader(asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n\n  async function readChunk() {\n    const next = await iterator.next();\n\n    if (next.done) {\n      return null;\n    }\n\n    return next.value;\n  }\n\n  return chunkReader(readChunk);\n}","map":{"version":3,"names":["varint","CID","Digest","decode","decodeDagCbor","CIDV0_BYTES","SHA2_256","LENGTH","DAG_PB","readVarint","reader","bytes","upTo","i","seek","readHeader","length","Error","header","exactly","block","Array","isArray","version","roots","Object","keys","filter","p","readMultihash","codeLength","subarray","lengthLength","mhLength","multihash","readCid","first","create","codec","readBlockHead","start","pos","cid","blockLength","readBlock","readBlockIndex","offset","index","blockOffset","createDecoder","headerPromise","blocks","blocksIndex","bytesReader","Math","min","chunkReader","readChunk","have","currentChunk","Uint8Array","read","bufa","chunk","push","reduce","c","off","b","set","asyncIterableReader","asyncIterable","iterator","Symbol","asyncIterator","next","done","value"],"sources":["/var/www/ch-8-car-renting/frontend/node_modules/@ipld/car/esm/lib/decoder.js"],"sourcesContent":["import varint from 'varint';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { decode as decodeDagCbor } from '@ipld/dag-cbor';\nconst CIDV0_BYTES = {\n  SHA2_256: 18,\n  LENGTH: 32,\n  DAG_PB: 112\n};\nasync function readVarint(reader) {\n  const bytes = await reader.upTo(8);\n  const i = varint.decode(bytes);\n  reader.seek(varint.decode.bytes);\n  return i;\n}\nexport async function readHeader(reader) {\n  const length = await readVarint(reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)');\n  }\n  const header = await reader.exactly(length);\n  reader.seek(length);\n  const block = decodeDagCbor(header);\n  if (block == null || Array.isArray(block) || typeof block !== 'object') {\n    throw new Error('Invalid CAR header format');\n  }\n  if (block.version !== 1) {\n    if (typeof block.version === 'string') {\n      throw new Error(`Invalid CAR version: \"${ block.version }\"`);\n    }\n    throw new Error(`Invalid CAR version: ${ block.version }`);\n  }\n  if (!Array.isArray(block.roots)) {\n    throw new Error('Invalid CAR header format');\n  }\n  if (Object.keys(block).filter(p => p !== 'roots' && p !== 'version').length) {\n    throw new Error('Invalid CAR header format');\n  }\n  return block;\n}\nasync function readMultihash(reader) {\n  const bytes = await reader.upTo(8);\n  varint.decode(bytes);\n  const codeLength = varint.decode.bytes;\n  const length = varint.decode(bytes.subarray(varint.decode.bytes));\n  const lengthLength = varint.decode.bytes;\n  const mhLength = codeLength + lengthLength + length;\n  const multihash = await reader.exactly(mhLength);\n  reader.seek(mhLength);\n  return multihash;\n}\nasync function readCid(reader) {\n  const first = await reader.exactly(2);\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    const bytes = await reader.exactly(34);\n    reader.seek(34);\n    const multihash = Digest.decode(bytes);\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash);\n  }\n  const version = await readVarint(reader);\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${ version })`);\n  }\n  const codec = await readVarint(reader);\n  const bytes = await readMultihash(reader);\n  const multihash = Digest.decode(bytes);\n  return CID.create(version, codec, multihash);\n}\nexport async function readBlockHead(reader) {\n  const start = reader.pos;\n  let length = await readVarint(reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)');\n  }\n  length += reader.pos - start;\n  const cid = await readCid(reader);\n  const blockLength = length - (reader.pos - start);\n  return {\n    cid,\n    length,\n    blockLength\n  };\n}\nasync function readBlock(reader) {\n  const {cid, blockLength} = await readBlockHead(reader);\n  const bytes = await reader.exactly(blockLength);\n  reader.seek(blockLength);\n  return {\n    bytes,\n    cid\n  };\n}\nasync function readBlockIndex(reader) {\n  const offset = reader.pos;\n  const {cid, length, blockLength} = await readBlockHead(reader);\n  const index = {\n    cid,\n    length,\n    blockLength,\n    offset,\n    blockOffset: reader.pos\n  };\n  reader.seek(index.blockLength);\n  return index;\n}\nexport function createDecoder(reader) {\n  const headerPromise = readHeader(reader);\n  return {\n    header: () => headerPromise,\n    async *blocks() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader);\n      }\n    },\n    async *blocksIndex() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader);\n      }\n    }\n  };\n}\nexport function bytesReader(bytes) {\n  let pos = 0;\n  return {\n    async upTo(length) {\n      return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));\n    },\n    async exactly(length) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data');\n      }\n      return bytes.subarray(pos, pos + length);\n    },\n    seek(length) {\n      pos += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nexport function chunkReader(readChunk) {\n  let pos = 0;\n  let have = 0;\n  let offset = 0;\n  let currentChunk = new Uint8Array(0);\n  const read = async length => {\n    have = currentChunk.length - offset;\n    const bufa = [currentChunk.subarray(offset)];\n    while (have < length) {\n      const chunk = await readChunk();\n      if (chunk == null) {\n        break;\n      }\n      if (have < 0) {\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have));\n        }\n      } else {\n        bufa.push(chunk);\n      }\n      have += chunk.length;\n    }\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));\n    let off = 0;\n    for (const b of bufa) {\n      currentChunk.set(b, off);\n      off += b.length;\n    }\n    offset = 0;\n  };\n  return {\n    async upTo(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length));\n    },\n    async exactly(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data');\n      }\n      return currentChunk.subarray(offset, offset + length);\n    },\n    seek(length) {\n      pos += length;\n      offset += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nexport function asyncIterableReader(asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  async function readChunk() {\n    const next = await iterator.next();\n    if (next.done) {\n      return null;\n    }\n    return next.value;\n  }\n  return chunkReader(readChunk);\n}"],"mappings":";;;AAAA,OAAOA,MAAP,MAAmB,QAAnB;AACA,SAASC,GAAT,QAAoB,kBAApB;AACA,OAAO,KAAKC,MAAZ,MAAwB,4BAAxB;AACA,SAASC,MAAM,IAAIC,aAAnB,QAAwC,gBAAxC;AACA,MAAMC,WAAW,GAAG;EAClBC,QAAQ,EAAE,EADQ;EAElBC,MAAM,EAAE,EAFU;EAGlBC,MAAM,EAAE;AAHU,CAApB;;AAKA,eAAeC,UAAf,CAA0BC,MAA1B,EAAkC;EAChC,MAAMC,KAAK,GAAG,MAAMD,MAAM,CAACE,IAAP,CAAY,CAAZ,CAApB;EACA,MAAMC,CAAC,GAAGb,MAAM,CAACG,MAAP,CAAcQ,KAAd,CAAV;EACAD,MAAM,CAACI,IAAP,CAAYd,MAAM,CAACG,MAAP,CAAcQ,KAA1B;EACA,OAAOE,CAAP;AACD;;AACD,OAAO,eAAeE,UAAf,CAA0BL,MAA1B,EAAkC;EACvC,MAAMM,MAAM,GAAG,MAAMP,UAAU,CAACC,MAAD,CAA/B;;EACA,IAAIM,MAAM,KAAK,CAAf,EAAkB;IAChB,MAAM,IAAIC,KAAJ,CAAU,kCAAV,CAAN;EACD;;EACD,MAAMC,MAAM,GAAG,MAAMR,MAAM,CAACS,OAAP,CAAeH,MAAf,CAArB;EACAN,MAAM,CAACI,IAAP,CAAYE,MAAZ;EACA,MAAMI,KAAK,GAAGhB,aAAa,CAACc,MAAD,CAA3B;;EACA,IAAIE,KAAK,IAAI,IAAT,IAAiBC,KAAK,CAACC,OAAN,CAAcF,KAAd,CAAjB,IAAyC,OAAOA,KAAP,KAAiB,QAA9D,EAAwE;IACtE,MAAM,IAAIH,KAAJ,CAAU,2BAAV,CAAN;EACD;;EACD,IAAIG,KAAK,CAACG,OAAN,KAAkB,CAAtB,EAAyB;IACvB,IAAI,OAAOH,KAAK,CAACG,OAAb,KAAyB,QAA7B,EAAuC;MACrC,MAAM,IAAIN,KAAJ,CAAW,yBAAyBG,KAAK,CAACG,OAAS,GAAnD,CAAN;IACD;;IACD,MAAM,IAAIN,KAAJ,CAAW,wBAAwBG,KAAK,CAACG,OAAS,EAAlD,CAAN;EACD;;EACD,IAAI,CAACF,KAAK,CAACC,OAAN,CAAcF,KAAK,CAACI,KAApB,CAAL,EAAiC;IAC/B,MAAM,IAAIP,KAAJ,CAAU,2BAAV,CAAN;EACD;;EACD,IAAIQ,MAAM,CAACC,IAAP,CAAYN,KAAZ,EAAmBO,MAAnB,CAA0BC,CAAC,IAAIA,CAAC,KAAK,OAAN,IAAiBA,CAAC,KAAK,SAAtD,EAAiEZ,MAArE,EAA6E;IAC3E,MAAM,IAAIC,KAAJ,CAAU,2BAAV,CAAN;EACD;;EACD,OAAOG,KAAP;AACD;;AACD,eAAeS,aAAf,CAA6BnB,MAA7B,EAAqC;EACnC,MAAMC,KAAK,GAAG,MAAMD,MAAM,CAACE,IAAP,CAAY,CAAZ,CAApB;EACAZ,MAAM,CAACG,MAAP,CAAcQ,KAAd;EACA,MAAMmB,UAAU,GAAG9B,MAAM,CAACG,MAAP,CAAcQ,KAAjC;EACA,MAAMK,MAAM,GAAGhB,MAAM,CAACG,MAAP,CAAcQ,KAAK,CAACoB,QAAN,CAAe/B,MAAM,CAACG,MAAP,CAAcQ,KAA7B,CAAd,CAAf;EACA,MAAMqB,YAAY,GAAGhC,MAAM,CAACG,MAAP,CAAcQ,KAAnC;EACA,MAAMsB,QAAQ,GAAGH,UAAU,GAAGE,YAAb,GAA4BhB,MAA7C;EACA,MAAMkB,SAAS,GAAG,MAAMxB,MAAM,CAACS,OAAP,CAAec,QAAf,CAAxB;EACAvB,MAAM,CAACI,IAAP,CAAYmB,QAAZ;EACA,OAAOC,SAAP;AACD;;AACD,eAAeC,OAAf,CAAuBzB,MAAvB,EAA+B;EAC7B,MAAM0B,KAAK,GAAG,MAAM1B,MAAM,CAACS,OAAP,CAAe,CAAf,CAApB;;EACA,IAAIiB,KAAK,CAAC,CAAD,CAAL,KAAa/B,WAAW,CAACC,QAAzB,IAAqC8B,KAAK,CAAC,CAAD,CAAL,KAAa/B,WAAW,CAACE,MAAlE,EAA0E;IACxE,MAAMI,KAAK,GAAG,MAAMD,MAAM,CAACS,OAAP,CAAe,EAAf,CAApB;IACAT,MAAM,CAACI,IAAP,CAAY,EAAZ;IACA,MAAMoB,SAAS,GAAGhC,MAAM,CAACC,MAAP,CAAcQ,KAAd,CAAlB;IACA,OAAOV,GAAG,CAACoC,MAAJ,CAAW,CAAX,EAAchC,WAAW,CAACG,MAA1B,EAAkC0B,SAAlC,CAAP;EACD;;EACD,MAAMX,OAAO,GAAG,MAAMd,UAAU,CAACC,MAAD,CAAhC;;EACA,IAAIa,OAAO,KAAK,CAAhB,EAAmB;IACjB,MAAM,IAAIN,KAAJ,CAAW,2BAA2BM,OAAS,GAA/C,CAAN;EACD;;EACD,MAAMe,KAAK,GAAG,MAAM7B,UAAU,CAACC,MAAD,CAA9B;EACA,MAAMC,KAAK,GAAG,MAAMkB,aAAa,CAACnB,MAAD,CAAjC;EACA,MAAMwB,SAAS,GAAGhC,MAAM,CAACC,MAAP,CAAcQ,KAAd,CAAlB;EACA,OAAOV,GAAG,CAACoC,MAAJ,CAAWd,OAAX,EAAoBe,KAApB,EAA2BJ,SAA3B,CAAP;AACD;;AACD,OAAO,eAAeK,aAAf,CAA6B7B,MAA7B,EAAqC;EAC1C,MAAM8B,KAAK,GAAG9B,MAAM,CAAC+B,GAArB;EACA,IAAIzB,MAAM,GAAG,MAAMP,UAAU,CAACC,MAAD,CAA7B;;EACA,IAAIM,MAAM,KAAK,CAAf,EAAkB;IAChB,MAAM,IAAIC,KAAJ,CAAU,mCAAV,CAAN;EACD;;EACDD,MAAM,IAAIN,MAAM,CAAC+B,GAAP,GAAaD,KAAvB;EACA,MAAME,GAAG,GAAG,MAAMP,OAAO,CAACzB,MAAD,CAAzB;EACA,MAAMiC,WAAW,GAAG3B,MAAM,IAAIN,MAAM,CAAC+B,GAAP,GAAaD,KAAjB,CAA1B;EACA,OAAO;IACLE,GADK;IAEL1B,MAFK;IAGL2B;EAHK,CAAP;AAKD;;AACD,eAAeC,SAAf,CAAyBlC,MAAzB,EAAiC;EAC/B,MAAM;IAACgC,GAAD;IAAMC;EAAN,IAAqB,MAAMJ,aAAa,CAAC7B,MAAD,CAA9C;EACA,MAAMC,KAAK,GAAG,MAAMD,MAAM,CAACS,OAAP,CAAewB,WAAf,CAApB;EACAjC,MAAM,CAACI,IAAP,CAAY6B,WAAZ;EACA,OAAO;IACLhC,KADK;IAEL+B;EAFK,CAAP;AAID;;AACD,eAAeG,cAAf,CAA8BnC,MAA9B,EAAsC;EACpC,MAAMoC,MAAM,GAAGpC,MAAM,CAAC+B,GAAtB;EACA,MAAM;IAACC,GAAD;IAAM1B,MAAN;IAAc2B;EAAd,IAA6B,MAAMJ,aAAa,CAAC7B,MAAD,CAAtD;EACA,MAAMqC,KAAK,GAAG;IACZL,GADY;IAEZ1B,MAFY;IAGZ2B,WAHY;IAIZG,MAJY;IAKZE,WAAW,EAAEtC,MAAM,CAAC+B;EALR,CAAd;EAOA/B,MAAM,CAACI,IAAP,CAAYiC,KAAK,CAACJ,WAAlB;EACA,OAAOI,KAAP;AACD;;AACD,OAAO,SAASE,aAAT,CAAuBvC,MAAvB,EAA+B;EACpC,MAAMwC,aAAa,GAAGnC,UAAU,CAACL,MAAD,CAAhC;EACA,OAAO;IACLQ,MAAM,EAAE,MAAMgC,aADT;;IAEL,OAAOC,MAAP,GAAgB;MACd,MAAMD,aAAN;;MACA,OAAO,CAAC,MAAMxC,MAAM,CAACE,IAAP,CAAY,CAAZ,CAAP,EAAuBI,MAAvB,GAAgC,CAAvC,EAA0C;QACxC,MAAM,MAAM4B,SAAS,CAAClC,MAAD,CAArB;MACD;IACF,CAPI;;IAQL,OAAO0C,WAAP,GAAqB;MACnB,MAAMF,aAAN;;MACA,OAAO,CAAC,MAAMxC,MAAM,CAACE,IAAP,CAAY,CAAZ,CAAP,EAAuBI,MAAvB,GAAgC,CAAvC,EAA0C;QACxC,MAAM,MAAM6B,cAAc,CAACnC,MAAD,CAA1B;MACD;IACF;;EAbI,CAAP;AAeD;AACD,OAAO,SAAS2C,WAAT,CAAqB1C,KAArB,EAA4B;EACjC,IAAI8B,GAAG,GAAG,CAAV;EACA,OAAO;IACL,MAAM7B,IAAN,CAAWI,MAAX,EAAmB;MACjB,OAAOL,KAAK,CAACoB,QAAN,CAAeU,GAAf,EAAoBA,GAAG,GAAGa,IAAI,CAACC,GAAL,CAASvC,MAAT,EAAiBL,KAAK,CAACK,MAAN,GAAeyB,GAAhC,CAA1B,CAAP;IACD,CAHI;;IAIL,MAAMtB,OAAN,CAAcH,MAAd,EAAsB;MACpB,IAAIA,MAAM,GAAGL,KAAK,CAACK,MAAN,GAAeyB,GAA5B,EAAiC;QAC/B,MAAM,IAAIxB,KAAJ,CAAU,wBAAV,CAAN;MACD;;MACD,OAAON,KAAK,CAACoB,QAAN,CAAeU,GAAf,EAAoBA,GAAG,GAAGzB,MAA1B,CAAP;IACD,CATI;;IAULF,IAAI,CAACE,MAAD,EAAS;MACXyB,GAAG,IAAIzB,MAAP;IACD,CAZI;;IAaL,IAAIyB,GAAJ,GAAU;MACR,OAAOA,GAAP;IACD;;EAfI,CAAP;AAiBD;AACD,OAAO,SAASe,WAAT,CAAqBC,SAArB,EAAgC;EACrC,IAAIhB,GAAG,GAAG,CAAV;EACA,IAAIiB,IAAI,GAAG,CAAX;EACA,IAAIZ,MAAM,GAAG,CAAb;EACA,IAAIa,YAAY,GAAG,IAAIC,UAAJ,CAAe,CAAf,CAAnB;;EACA,MAAMC,IAAI,GAAG,MAAM7C,MAAN,IAAgB;IAC3B0C,IAAI,GAAGC,YAAY,CAAC3C,MAAb,GAAsB8B,MAA7B;IACA,MAAMgB,IAAI,GAAG,CAACH,YAAY,CAAC5B,QAAb,CAAsBe,MAAtB,CAAD,CAAb;;IACA,OAAOY,IAAI,GAAG1C,MAAd,EAAsB;MACpB,MAAM+C,KAAK,GAAG,MAAMN,SAAS,EAA7B;;MACA,IAAIM,KAAK,IAAI,IAAb,EAAmB;QACjB;MACD;;MACD,IAAIL,IAAI,GAAG,CAAX,EAAc;QACZ,IAAIK,KAAK,CAAC/C,MAAN,GAAe0C,IAAnB,EAAyB;UACvBI,IAAI,CAACE,IAAL,CAAUD,KAAK,CAAChC,QAAN,CAAe,CAAC2B,IAAhB,CAAV;QACD;MACF,CAJD,MAIO;QACLI,IAAI,CAACE,IAAL,CAAUD,KAAV;MACD;;MACDL,IAAI,IAAIK,KAAK,CAAC/C,MAAd;IACD;;IACD2C,YAAY,GAAG,IAAIC,UAAJ,CAAeE,IAAI,CAACG,MAAL,CAAY,CAACrC,CAAD,EAAIsC,CAAJ,KAAUtC,CAAC,GAAGsC,CAAC,CAAClD,MAA5B,EAAoC,CAApC,CAAf,CAAf;IACA,IAAImD,GAAG,GAAG,CAAV;;IACA,KAAK,MAAMC,CAAX,IAAgBN,IAAhB,EAAsB;MACpBH,YAAY,CAACU,GAAb,CAAiBD,CAAjB,EAAoBD,GAApB;MACAA,GAAG,IAAIC,CAAC,CAACpD,MAAT;IACD;;IACD8B,MAAM,GAAG,CAAT;EACD,CAxBD;;EAyBA,OAAO;IACL,MAAMlC,IAAN,CAAWI,MAAX,EAAmB;MACjB,IAAI2C,YAAY,CAAC3C,MAAb,GAAsB8B,MAAtB,GAA+B9B,MAAnC,EAA2C;QACzC,MAAM6C,IAAI,CAAC7C,MAAD,CAAV;MACD;;MACD,OAAO2C,YAAY,CAAC5B,QAAb,CAAsBe,MAAtB,EAA8BA,MAAM,GAAGQ,IAAI,CAACC,GAAL,CAASI,YAAY,CAAC3C,MAAb,GAAsB8B,MAA/B,EAAuC9B,MAAvC,CAAvC,CAAP;IACD,CANI;;IAOL,MAAMG,OAAN,CAAcH,MAAd,EAAsB;MACpB,IAAI2C,YAAY,CAAC3C,MAAb,GAAsB8B,MAAtB,GAA+B9B,MAAnC,EAA2C;QACzC,MAAM6C,IAAI,CAAC7C,MAAD,CAAV;MACD;;MACD,IAAI2C,YAAY,CAAC3C,MAAb,GAAsB8B,MAAtB,GAA+B9B,MAAnC,EAA2C;QACzC,MAAM,IAAIC,KAAJ,CAAU,wBAAV,CAAN;MACD;;MACD,OAAO0C,YAAY,CAAC5B,QAAb,CAAsBe,MAAtB,EAA8BA,MAAM,GAAG9B,MAAvC,CAAP;IACD,CAfI;;IAgBLF,IAAI,CAACE,MAAD,EAAS;MACXyB,GAAG,IAAIzB,MAAP;MACA8B,MAAM,IAAI9B,MAAV;IACD,CAnBI;;IAoBL,IAAIyB,GAAJ,GAAU;MACR,OAAOA,GAAP;IACD;;EAtBI,CAAP;AAwBD;AACD,OAAO,SAAS6B,mBAAT,CAA6BC,aAA7B,EAA4C;EACjD,MAAMC,QAAQ,GAAGD,aAAa,CAACE,MAAM,CAACC,aAAR,CAAb,EAAjB;;EACA,eAAejB,SAAf,GAA2B;IACzB,MAAMkB,IAAI,GAAG,MAAMH,QAAQ,CAACG,IAAT,EAAnB;;IACA,IAAIA,IAAI,CAACC,IAAT,EAAe;MACb,OAAO,IAAP;IACD;;IACD,OAAOD,IAAI,CAACE,KAAZ;EACD;;EACD,OAAOrB,WAAW,CAACC,SAAD,CAAlB;AACD"},"metadata":{},"sourceType":"module"}