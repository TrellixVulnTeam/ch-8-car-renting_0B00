{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport varint from 'varint';\nimport { encode as dagCborEncode } from '@ipld/dag-cbor';\nexport function createHeader(roots) {\n  const headerBytes = dagCborEncode({\n    version: 1,\n    roots\n  });\n  const varintBytes = varint.encode(headerBytes.length);\n  const header = new Uint8Array(varintBytes.length + headerBytes.length);\n  header.set(varintBytes, 0);\n  header.set(headerBytes, varintBytes.length);\n  return header;\n}\n\nfunction createEncoder(writer) {\n  return {\n    async setRoots(roots) {\n      const bytes = createHeader(roots);\n      await writer.write(bytes);\n    },\n\n    async writeBlock(block) {\n      const {\n        cid,\n        bytes\n      } = block;\n      await writer.write(new Uint8Array(varint.encode(cid.bytes.length + bytes.length)));\n      await writer.write(cid.bytes);\n\n      if (bytes.length) {\n        await writer.write(bytes);\n      }\n    },\n\n    async close() {\n      return writer.end();\n    }\n\n  };\n}\n\nexport { createEncoder };","map":{"version":3,"names":["varint","encode","dagCborEncode","createHeader","roots","headerBytes","version","varintBytes","length","header","Uint8Array","set","createEncoder","writer","setRoots","bytes","write","writeBlock","block","cid","close","end"],"sources":["/var/www/ch-8-car-renting/frontend/node_modules/@ipld/car/esm/lib/encoder.js"],"sourcesContent":["import varint from 'varint';\nimport { encode as dagCborEncode } from '@ipld/dag-cbor';\nexport function createHeader(roots) {\n  const headerBytes = dagCborEncode({\n    version: 1,\n    roots\n  });\n  const varintBytes = varint.encode(headerBytes.length);\n  const header = new Uint8Array(varintBytes.length + headerBytes.length);\n  header.set(varintBytes, 0);\n  header.set(headerBytes, varintBytes.length);\n  return header;\n}\nfunction createEncoder(writer) {\n  return {\n    async setRoots(roots) {\n      const bytes = createHeader(roots);\n      await writer.write(bytes);\n    },\n    async writeBlock(block) {\n      const {cid, bytes} = block;\n      await writer.write(new Uint8Array(varint.encode(cid.bytes.length + bytes.length)));\n      await writer.write(cid.bytes);\n      if (bytes.length) {\n        await writer.write(bytes);\n      }\n    },\n    async close() {\n      return writer.end();\n    }\n  };\n}\nexport {\n  createEncoder\n};"],"mappings":";;AAAA,OAAOA,MAAP,MAAmB,QAAnB;AACA,SAASC,MAAM,IAAIC,aAAnB,QAAwC,gBAAxC;AACA,OAAO,SAASC,YAAT,CAAsBC,KAAtB,EAA6B;EAClC,MAAMC,WAAW,GAAGH,aAAa,CAAC;IAChCI,OAAO,EAAE,CADuB;IAEhCF;EAFgC,CAAD,CAAjC;EAIA,MAAMG,WAAW,GAAGP,MAAM,CAACC,MAAP,CAAcI,WAAW,CAACG,MAA1B,CAApB;EACA,MAAMC,MAAM,GAAG,IAAIC,UAAJ,CAAeH,WAAW,CAACC,MAAZ,GAAqBH,WAAW,CAACG,MAAhD,CAAf;EACAC,MAAM,CAACE,GAAP,CAAWJ,WAAX,EAAwB,CAAxB;EACAE,MAAM,CAACE,GAAP,CAAWN,WAAX,EAAwBE,WAAW,CAACC,MAApC;EACA,OAAOC,MAAP;AACD;;AACD,SAASG,aAAT,CAAuBC,MAAvB,EAA+B;EAC7B,OAAO;IACL,MAAMC,QAAN,CAAeV,KAAf,EAAsB;MACpB,MAAMW,KAAK,GAAGZ,YAAY,CAACC,KAAD,CAA1B;MACA,MAAMS,MAAM,CAACG,KAAP,CAAaD,KAAb,CAAN;IACD,CAJI;;IAKL,MAAME,UAAN,CAAiBC,KAAjB,EAAwB;MACtB,MAAM;QAACC,GAAD;QAAMJ;MAAN,IAAeG,KAArB;MACA,MAAML,MAAM,CAACG,KAAP,CAAa,IAAIN,UAAJ,CAAeV,MAAM,CAACC,MAAP,CAAckB,GAAG,CAACJ,KAAJ,CAAUP,MAAV,GAAmBO,KAAK,CAACP,MAAvC,CAAf,CAAb,CAAN;MACA,MAAMK,MAAM,CAACG,KAAP,CAAaG,GAAG,CAACJ,KAAjB,CAAN;;MACA,IAAIA,KAAK,CAACP,MAAV,EAAkB;QAChB,MAAMK,MAAM,CAACG,KAAP,CAAaD,KAAb,CAAN;MACD;IACF,CAZI;;IAaL,MAAMK,KAAN,GAAc;MACZ,OAAOP,MAAM,CAACQ,GAAP,EAAP;IACD;;EAfI,CAAP;AAiBD;;AACD,SACET,aADF"},"metadata":{},"sourceType":"module"}